;;; Setup.

;;; This is unnecessarily complicated, so It's a good idea to skip through lightly and
;;; hit the key chords at the indicated points.

;;; However, if you're the kind of person that needs to understand what's actually
;;; happening, I can sympathize. It's like this:
;;; 1) We're running the "simple-httpd" webserver in emacs to serve the web page
;;; 2) We're running lisp itself (happens to be sbcl for me) in it's own process
;;; 3) We're running "slime" inside emacs itself to connect to that lisp process
;;; 4) We're running parenscript (in lisp) to compile the parenscript into javascript
;;; 5) We're using skewer (in emacs) to run inject the javascript into the webpage
;;; 6) We're using trident (in emacs) to help run the code through parenscript and skewer

;;; Have fun keeping the 3 and a half contexts straight :)
;;; It does get a lot easier after a little practice
(quote ;; Code for slime (not trident)
 (ql:quickload :parenscript)
 ;;                         ^^ (M-x slime-eval-last-expression) here
 )

(quote ;; More Code for slime (not trident)
 ;;                         ^^ (M-x slime-eval-last-expression) here
 (progn
   (import 'SB-DEBUG:VAR)
   (use-package :parenscript) ; This causes a conflict 'var'. We want to keep SB-DEBUG:var or things get nasty

   ;; Land of Lisp uses defparameter, but parenscript only has defvar :(
   ;; (It's not relevant, but if you need to know the difference: https://stackoverflow.com/questions/8927741/whats-difference-betritween-defvar-defparameter-setf-and-setq )
   ;; Luckily, parenscript predates 'const' in js, so we can just rewrite one to the other:
   (ps:defpsmacro defparameter (&body body)
     `(defvar ,@body))

   (ps:defpsmacro defmake (name)
     `(defmacro ,(intern (format nil "MAKE-~a" name)) (&rest props)
        `(ps:create ,@props)))

   (ps:defpsmacro define-accessor (struct-name slot-name)
     `(defmacro ,(intern (format nil "~a-~a" struct-name slot-name)) (obj)
        `(ps:getprop ,obj ,,(SYMBOL-TO-JS-STRING slot-name))))

   (ps:define-ps-symbol-macro cons list)

   (ps:defpsmacro cons (&rest args)
     `(list ,@args))

   (ps:defpsmacro defstruct (struct-name &rest slots)
     `(progn
        (defmake ,struct-name)
        ,@(loop for slot in slots collect
               `(define-accessor ,struct-name ,slot))))

   ;; We need to use a macro for gethash because it's a place
   (ps:defpsmacro gethash (key obj)
     `(ps:getprop ,obj ,key))

   ;; We need to use a macro for nth because it's a place
   (ps:defpsmacro nth (n list)
     `(getprop ,list ,n))

   )
 ;; ^^ (M-x slime-eval-last-expression) here
 )


;; Evaluate in emacs context by putting your cursor at the end of the expression
;; and hitting (C-c m e):
;; (Note that "steal-slime-keys-for-trident" is going change the behaviour of C-x C-e
;; from "slime-eval-last-expression" to "trident-eval-last-expression",
;; so the key chord evaluates code in the browser instead of in the local lisp)
(quote ;; This quote is to stop slime/trident from running the code meant for emacs
 (progn
   ;; Setup emacs environment
   (progn
     (lisp-mode)
     (trident-mode)
     (steal-slime-keys-for-trident!))

   ;; Setup skewer
   (progn
     (setq httpd-port 8081)  ; I'm already using the default port 8080
     (httpd-serve-directory (format "%s/" default-directory))
     (browse-url (format "http://127.0.0.1:%d/evolve.html" httpd-port)))

   ;; Plug some missing runtime functionality (with lodash)
   (progn
     (mapcar 'skewer-eval
             '("some = _.flip( _.some )"
               "removeIf = _.flip( _.reject )"
               "mapc = _.flip( _.map )"
               "car = _.head"
               "cdr = _.tail"
               "plus = (...args) => _.sum(args)"
               "plus = (...args) => _.sum(args)"
               "copyStructure = _.cloneDeep"
               "copyList = _.cloneDeep"
               ))
     )
   )
 ;; ^^ (C-c m e) Here for all that
 )


(defun lg (&rest args)
  ((ps:getprop console 'log 'apply) console args))
(lg "Trident is working as expected")
;;                                    ^^ C-x C-e here, check that the message
;;                                       appears in your browser

;; Plug some gaps between what Parenscript offers and evolution.lisp needs

(setf parse-integer (@ +number parse-int))

;; Parenscript defines equal with a macro, so #'equal is a problem
;; We don't actually use this function, it just needs to exist
(defun equal (l r)
  (equal l r))

;; This is pretty dirty.
;; Thank you, javascript, for buying a list as a valid key ;)
(defun make-hash-table (&key test)
  (ps:create))

(defun remhash (key hash-table)
  (delete (getprop hash-table key)))

(defun zerop (value)
  (equal value 0))

(defun push (value list)
  ((getprop list 'push) value))




(defstruct animal x y energy dir genes)

(defparameter *width* 100)
(defparameter *height* 30)
(defparameter *jungle* '(45 10 10 10))
(defparameter *plant-energy* 80)

(defparameter *plants* (make-hash-table :test #'equal))

(defun random-plant (left top width height)
   (let ((pos (cons (+ left (random width)) (+ top (random height)))))
        (setf (gethash pos *plants*) t)))

(defun add-plants ()
   (apply #'random-plant *jungle*)
   (random-plant 0 0 *width* *height*))

(defstruct animal x y energy dir genes)

(defparameter *animals*
    (list (make-animal :x      (ash *width*  -1)
                       :y      (ash *height* -1)
                       :energy 1000
                       :dir    0
                       :genes  (loop repeat 8
                                     collect (1+ (random 10)))))) ; Was "collecting"

(defun move (animal)
  (let ((dir (animal-dir animal))
        (x (animal-x animal))
        (y (animal-y animal)))
    (setf (animal-x animal) (mod (+ x
                                    (cond ((and (>= dir 2) (< dir 5)) 1)
                                          ((or (= dir 1) (= dir 5)) 0)
                                          (t -1))
                                    *width*)
                                 *width*))
    (setf (animal-y animal) (mod (+ y
                                    (cond ((and (>= dir 0) (< dir 3)) -1)
                                          ((and (>= dir 4) (< dir 7)) 1)
                                          (t 0))
                                    *height*)
                                 *height*))
    (decf (animal-energy animal))))

(defun turn (animal)
  (let ((x (random (apply #'+ (animal-genes animal)))))
    (labels ((angle (genes x)
               (let ((xnu (- x (car genes))))
                 (if (< xnu 0)
                     0
                     (1+ (angle (cdr genes) xnu))))))
        (setf (animal-dir animal)
              (mod (+ (animal-dir animal) (angle (animal-genes animal) x)) 8)))))

(defun eat (animal)
  (let ((pos (cons (animal-x animal) (animal-y animal))))
    (when (gethash pos *plants*)
      (incf (animal-energy animal) *plant-energy*)
      (remhash pos *plants*))))

(defparameter *reproduction-energy* 200)

(defun reproduce (animal)
  (let ((e (animal-energy animal)))
    (when (>= e *reproduction-energy*)
      (setf (animal-energy animal) (ash e -1))
      (let ((animal-nu (copy-structure animal))
            (genes     (copy-list (animal-genes animal)))
            (mutation  (random 8)))
        (setf (nth mutation genes) (max 1 (+ (nth mutation genes) (random 3) -1)))
        (setf (animal-genes animal-nu) genes)
        (push animal-nu *animals*)))))

(setf *world-age* 0)
(defun update-world ()
  (incf *world-age*)
  (setf *animals* (remove-if (lambda (animal)
                                 (<= (animal-energy animal) 0))
                             *animals*))
  (mapc (lambda (animal)
          (turn animal)
          (move animal)
          (eat animal)
          (reproduce animal))
        *animals*)
  (add-plants))

;; Parenscript's loop handling assumes that there's a from before a below
;; in ps-loop.lisp
;; It would be nice to fix this - sbcl has no problem with it, and the
;; The ANSI standard includes examples like this, e.g.
;; https://github.com/sbcl/ansi-cl-tests/blob/a755e2480caed1d3010943a9fbcfe61155a9240f/loop1.lsp#L185
;; (loop for x below 5 collect x) ; => (0 1 2 3 4)
;; I'd need to update PARENSCRIPT::for-clause and/or PARENSCRIPT::for-from
;; For now, though, I'm just going to make parenscript happy
(defun draw-world ()
  (loop for y
        from 0
        below *height*
        do (progn (fresh-line)
                  (princ "|")
                  (loop for x
                        from 0
                        below *width*
                        do (princ (cond ((some (lambda (animal)
                                                 (and (= (animal-x animal) x)
                                                      (= (animal-y animal) y)))
                                               *animals*)
                                         #\M)
                                        ((gethash (cons x y) *plants*) #\*)
                                         (t #\space))))
                  (princ "|"))))


;; Just another hack for now
(setf princ-buffer "")
(defun fresh-line ()
  ((@ console log) princ-buffer)
  (setf princ-buffer ""))
(defun princ (string)
  (setf princ-buffer (+ princ-buffer string)))

(setf *read-line* "quit")
(defun read-line ()
  *read-line*)

(defun step ()
  (update-world)
  (draw-world)
  (fresh-line))

(defun evolution ()
  (draw-world)
  (fresh-line)
  (let ((str (read-line)))
    (cond ((equal str "quit") ())
          (t (let ((x (parse-integer str :junk-allowed t)))
               (if x
                   (loop for i
                        from 0
                      below x
                      do (update-world)
                      if (zerop (mod i 1000))
                      do (princ #\.))
                   (update-world))
               (evolution))))))
