;;; Setup.

;;; This is unnecessarily complicated, so It's a good idea to skip through lightly and
;;; hit the key chords at the indicated points.

;;; However, if you're the kind of person that needs to understand what's actually
;;; happening, I can sympathize. It's like this:
;;; 1) We're running the "simple-httpd" webserver in emacs to serve the web page
;;; 2) We're running lisp itself (happens to be sbcl for me) in it's own process
;;; 3) We're running "slime" inside emacs itself to connect to that lisp process
;;; 4) We're running parenscript (in lisp) to compile the parenscript into javascript
;;; 5) We're using skewer (in emacs) to run inject the javascript into the webpage
;;; 6) We're using trident (in emacs) to help run the code through parenscript and skewer

;;; Have fun keeping the 3 and a half contexts straight :)
;;; It does get a lot easier after a little practice

;; First, we'll get emacs sorted.
;; Evaluate in emacs context by putting your cursor at the end of the expression
;; and hitting (C-c m e):
;; (Note that "steal-slime-keys-for-trident" is going change the behaviour of C-x C-e
;; from "slime-eval-last-expression" to "trident-eval-last-expression",
;; so the key chord evaluates code in the browser instead of in the local lisp)
(quote ;; This quote is to stop slime/trident from running the code meant for emacs
 (progn
   ;; Setup emacs environment
   (progn
     (lisp-mode)
     (trident-mode)
     (steal-slime-keys-for-trident!))

   ;; Setup skewer
   (progn
     (setq httpd-port 8081)  ; I'm already using the default port 8080
     (httpd-serve-directory (format "%s/" default-directory))
     (browse-url (format "http://127.0.0.1:%d/evolve.html" httpd-port)))
   )
 ;; ^^ (C-c m e) Here for all that
 )



(quote ;; Code for slime (not trident)
 (progn
   (ql:quickload :parenscript)
   ;;                         ^^ (M-x slime-eval-last-expression-in-repl) here
   (import 'sb-debug:var)
   ;;                         ^^ (M-x slime-eval-last-expression-in-repl) here
   (shadow 'var)
   ;;                         ^^ (M-x slime-eval-last-expression-in-repl) here
   (use-package :parenscript)
   ;;                         ^^ (M-x slime-eval-last-expression-in-repl) here
   )
 )

(quote ;; More Code for lisp/slime (not trident)
 ;;                         ^^ (M-x slime-eval-last-expression) here
 (progn
   ;; Land of Lisp uses defparameter, but parenscript only has defvar :(
   ;; (It's not relevant, but if you need to know the difference: https://stackoverflow.com/questions/8927741/whats-difference-betritween-defvar-defparameter-setf-and-setq )
   ;; Luckily, parenscript predates 'const' in js, so we can just rewrite one to the other:
   (ps:defpsmacro defparameter (&body body)
     `(defvar ,@body))

   (ps:defpsmacro defmake (name)
     `(defmacro ,(intern (format nil "MAKE-~a" name)) (&rest props)
        `(ps:create ,@props)))

   (ps:defpsmacro define-accessor (struct-name slot-name)
     `(defmacro ,(intern (format nil "~a-~a" struct-name slot-name)) (obj)
        `(ps:getprop ,obj ,,(SYMBOL-TO-JS-STRING slot-name))))

   (ps:define-ps-symbol-macro cons list)

   (ps:defpsmacro cons (&rest args)
     `(list ,@args))

   (ps:defpsmacro defstruct (struct-name &rest slots)
     `(progn
        (defmake ,struct-name)
        ,@(loop for slot in slots collect
               `(define-accessor ,struct-name ,slot))))

   ;; We need to use a macro for gethash because it's a place
   (ps:defpsmacro gethash (key obj)
     `(ps:getprop ,obj ,key))

   ;; We need to use a macro for nth because it's a place
   (ps:defpsmacro nth (n list)
     `(getprop ,list ,n))

   )
 ;; ^^ (M-x slime-eval-last-expression) here
 )

;;; Build:
;;; M-x trident-compile-buffer-to-file (ret) "evolve.js"
(quote
 ((@ location reload))
 ;;                    ^ C-x C-e reload the page
 )

(defun plus (&rest args) ((@ _ sum) args))
(setf lodash-subs
      '((car head)
        (cdr tail)
        (copy-structure "cloneDeep")
        (copy-list "cloneDeep")))
(setf lodash-flip-subs
      '((some some)
        (remove-if reject)
        (mapc map)))

(loop
   for (local remote) in lodash-subs
   do (setf (getprop this local) (getprop _ remote)))
(loop
   for (local remote) in lodash-flip-subs
   do (setf (getprop this local) ((@ _ flip) (getprop _ remote))))

(defun lg (&rest args)
  ((ps:getprop console 'log 'apply) console args))
(lg "Trident is working as expected")
;;                                    ^^ C-x C-e here, check that the message
;;                                       appears in your browser

;; Plug some gaps between what Parenscript offers and evolution.lisp needs

(setf parse-integer (@ +number parse-int))

;; Parenscript defines equal with a macro, so #'equal is a problem
;; We don't actually use this function, it just needs to exist
(defun equal (l r)
  (equal l r))

;; This is pretty dirty.
;; Thank you, javascript, for buying a list as a valid key ;)
(defun make-hash-table (&key test)
  (ps:create))

(defun remhash (key hash-table)
  (delete (getprop hash-table key)))

(defun zerop (value)
  (equal value 0))

(defun push (value list)
  ((getprop list 'push) value))




(defstruct animal x y energy dir genes)

(defparameter *width* 100)
(defparameter *height* 30)
(defparameter *jungle* '(45 10 10 10))
(defparameter *plant-energy* 80)

(defparameter *plants* (make-hash-table :test #'equal))

(defun random-plant (left top width height)
   (let ((pos (cons (+ left (random width)) (+ top (random height)))))
        (setf (gethash pos *plants*) t)))

(defun add-plants ()
   (apply #'random-plant *jungle*)
   (random-plant 0 0 *width* *height*))

(defstruct animal x y energy dir genes)

(defparameter *animals*
    (list (make-animal :x      (ash *width*  -1)
                       :y      (ash *height* -1)
                       :energy 1000
                       :dir    0
                       :genes  (loop repeat 8
                                     collect (1+ (random 10)))))) ; Was "collecting"

(defun move (animal)
  (let ((dir (animal-dir animal))
        (x (animal-x animal))
        (y (animal-y animal)))
    (setf (animal-x animal) (mod (+ x
                                    (cond ((and (>= dir 2) (< dir 5)) 1)
                                          ((or (= dir 1) (= dir 5)) 0)
                                          (t -1))
                                    *width*)
                                 *width*))
    (setf (animal-y animal) (mod (+ y
                                    (cond ((and (>= dir 0) (< dir 3)) -1)
                                          ((and (>= dir 4) (< dir 7)) 1)
                                          (t 0))
                                    *height*)
                                 *height*))
    (decf (animal-energy animal))))

(defun turn (animal)
  (let ((x (random (apply #'+ (animal-genes animal)))))
    (labels ((angle (genes x)
               (let ((xnu (- x (car genes))))
                 (if (< xnu 0)
                     0
                     (1+ (angle (cdr genes) xnu))))))
        (setf (animal-dir animal)
              (mod (+ (animal-dir animal) (angle (animal-genes animal) x)) 8)))))

(defun eat (animal)
  (let ((pos (cons (animal-x animal) (animal-y animal))))
    (when (gethash pos *plants*)
      (incf (animal-energy animal) *plant-energy*)
      (remhash pos *plants*))))

(defparameter *reproduction-energy* 200)

(defun reproduce (animal)
  (let ((e (animal-energy animal)))
    (when (>= e *reproduction-energy*)
      (setf (animal-energy animal) (ash e -1))
      (let ((animal-nu (copy-structure animal))
            (genes     (copy-list (animal-genes animal)))
            (mutation  (random 8)))
        (setf (nth mutation genes) (max 1 (+ (nth mutation genes) (random 3) -1)))
        (setf (animal-genes animal-nu) genes)
        (push animal-nu *animals*)))))

(setf *world-age* 0)
(defun update-world ()
  (increment-world-age)
  (setf *animals* (remove-if (lambda (animal)
                                 (<= (animal-energy animal) 0))
                             *animals*))
  (mapc (lambda (animal)
          (turn animal)
          (move animal)
          (eat animal)
          (reproduce animal))
        *animals*)
  (add-plants))

;; Parenscript's loop handling assumes that there's a from before a below
;; in ps-loop.lisp
;; It would be nice to fix this - sbcl has no problem with it, and the
;; The ANSI standard includes examples like this, e.g.
;; https://github.com/sbcl/ansi-cl-tests/blob/a755e2480caed1d3010943a9fbcfe61155a9240f/loop1.lsp#L185
;; (loop for x below 5 collect x) ; => (0 1 2 3 4)
;; I'd need to update PARENSCRIPT::for-clause and/or PARENSCRIPT::for-from
;; For now, though, I'm just going to make parenscript happy
(defun draw-world ()
  (loop for y
        from 0
        below *height*
        do (progn (fresh-line)
                  (princ "|")
                  (loop for x
                        from 0
                        below *width*
                        do (princ (cond ((some (lambda (animal)
                                                 (and (= (animal-x animal) x)
                                                      (= (animal-y animal) y)))
                                               *animals*)
                                         #\M)
                                        ((gethash (cons x y) *plants*) #\*)
                                         (t #\space))))
                  (princ "|"))))

(defun evolution ()
  (draw-world)
  (fresh-line)
  (let ((str (read-line)))
    (cond ((equal str "quit") ())
          (t (let ((x (parse-integer str :junk-allowed t)))
               (if x
                   (loop for i
                        from 0
                      below x
                      do (update-world)
                      if (zerop (mod i 1000))
                      do (princ #\.))
                   (update-world))
               (set-timeout evolution))))))


;;; Browser specific functionality
(setf world-element ((@ document "getElementById") "world"))
(setf world-age-element ((@ document "getElementById") "world-age"))
(setf run-button ((@ document "getElementById") "run"))
(setf pause-button ((@ document "getElementById") "pause"))
(setf step-button ((@ document "getElementById") "step"))

(setf (@ world-element rows) (+ 1 *height*))
(setf (@ world-element cols) (+ 2 *width*))

(setf princ-buffer "")
(defun draw-world-browser ()
  (setf princ-buffer "")
  (draw-world)
  (setf (@ world-element value) princ-buffer)
  (setf )
  )

(defun fresh-line ()
  ;; Don't render the first line-feed
  (and princ-buffer (princ #\linefeed))
;  (setf (@ world-div "innerText") princ-buffer)
  ;(setf princ-buffer "")
  )

(defun princ (string)
  (setf princ-buffer (+ princ-buffer string)))

(setf *temp-readline-value* 1)
(setf *read-line* "quit")
(defun read-line ()
  (let ((value (or *temp-readline-value* "quit")))
    (setf *temp-readline-value* nil)
    value))

(defun async-loop (fun))

(defun enter (n)
  (setf *running* (+ *world-age* n))
  (running-step))


(defun step (&optional (draw t))
  (update-world)
  (and draw (draw-world-browser))
  (fresh-line))

(setf *running* nil)
(defun run (&optional (steps +infinity))
  (setf *running* (+ *world-age* steps))
  (running-step))

(setf *world-render-period* 10000)
(setf *world-age-render-period* 100)
(defun running-step ()
  (let* ((finished (not (< *world-age* *running*)))
         (should-draw-world (or finished
                                (= 0 (mod *world-age* *world-render-period*))))
         (should-draw-world-age (or finished
                                    (= 0 (mod *world-age* *world-age-render-period*))))
         (drawing-something (or should-draw-world should-draw-world-age)))
    (or finished (update-world))
    (and should-draw-world (draw-world-browser))
    (and should-draw-world-age (draw-world-age))
    (or finished
        (progn
          ;; We need to release the main thread for updates, but that's a pretty
          ;; bad bottleneck when we're running a lot of generations, so setTimeout()
          ;; when we want to draw
          ;; Parenscript lacks tail call optimization, so the setTimeout also
          ;; serves to protect the stack
          (if drawing-something
              (set-timeout #'running-step)
              (running-step))))))

(defun stop ()
  (setf *running* nil))

(defun draw-world-age (&optional (age *world-age*))
  (and world-age-element
       (setf (@ world-age-element "innerText") age)))

(defun increment-world-age ()
    (incf *world-age*)
    (draw-world-age))

;; Hook up html buttons

(defun get-element-by-id (id)
  ((@ document "getElementById") id))

(setf run-for-input-element (get-element-by-id "run-for-input"))
(defun run-for-input-value ()
  (run (+Number (@ run-for-input-element value))))

(defun assign-on-click (button-id callback)
  (setf (getprop ((@ document "getElementById") button-id) "onclick") callback))

(assign-on-click "run" run)
(assign-on-click "stop" stop)
(assign-on-click "step" step)
(assign-on-click "run-for" run-for-input-value)

(defun scope-state-name (name)
  (+ "evolve:" name))

;;; I should probably fix these to use place semantics
(defun save-item (name value)
  ((@ local-storage "setItem") (scope-state-name name) ((@ *json* stringify) value))
  value)

(defun load-item (name)
  ((@ *json* parse) (@ local-storage (scope-state-name name))))

(defun create-current-state-object ()
  (create world-age *world-age*
          animals *animals*
          plants *plants*))

(defun save-state (&optional (name "state"))
    (save-item name (create-current-state-object)))

(defun load-state (&optional (name "state"))
  (let ((current-state (load-item name)))
    (with-slots (world-age animals plants) current-state
        (setf *world-age* world-age
              *animals* animals
              *plants* plants))
    (draw-world-browser)
    (draw-world-age)
    current-state))

(draw-world-browser)
(enter 1)
